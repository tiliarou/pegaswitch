/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
var sploitcore = require('./sploitcore');
var sploitMixin = require('./sploitMixin');
var svcMixin = require('./svc');
var utils = require('./utils');
var ResultCode = require('./ResultCode');
var Result = require('./Result');

function IPCMessage (sc, sender, cmdId) {
	this.sc = sc;
	this.sender = sender;
	this.pid = null;
	this.type = 4;
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	this.success = this.resultCode === 0 || this.resultCode === undefined;
	this.dataBuffer = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];
	this.objectDomainCommand = undefined;
	this.objectId = 0;
	this.inputObjectIds = [];
	this.copyBuffers = [];
}

IPCMessage.prototype.setType = function (t) {
	this.type = t;
	return this;
};

IPCMessage.prototype.sendPid = function () {
	this.pid = true;
	return this;
};

IPCMessage.prototype.setCmd = function (cmdId) {
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	return this;
};

IPCMessage.prototype.setResult = function (rescode) {
	this.setCmd(rescode);
	this.success = this.resultCode === 0;
};

IPCMessage.prototype.data = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = arguments[i];
		if (v instanceof Array) {
			this.dataBuffer.push(v[0]);
			this.dataBuffer.push(v[1]);
		} else if(typeof(v) === "number") {
			this.dataBuffer.push(v);
			this.dataBuffer.push(0);
		} else {
			throw new Error("can't put in an IPC request: " + v);
		}
	}

	return this;
};

IPCMessage.prototype.datau32 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		this.dataBuffer.push(utils.trunc32(arguments[i]));
	}
	return this;
};

IPCMessage.prototype.datau64 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = utils.pad64(arguments[i]);
		this.dataBuffer.push(v[0]);
		this.dataBuffer.push(v[1]);
	}

	return this;
};

IPCMessage.prototype.dataArrayBuffer = function(ab) {
	this.dataBuffer = [];
	var u32 = new Uint32Array(ab);
	for(var i = 0; i < u32.length; i++) {
		this.dataBuffer[i] = u32[i];
	}

	return this;
};

IPCMessage.prototype.addDescriptor = function (da, addr, size, third) {
	if (addr instanceof ArrayBuffer || ArrayBuffer.isView(addr)) {
		var buf = addr;
		if (size === undefined) {
			size = buf.byteLength;
		}
		if (this.sender.isBrowser) {
			if (buf.addr === undefined) {
				buf.addr = this.sc.getArrayBufferAddr(buf);
			}
			addr = buf.addr;
		} else {
			addr = this.sender.malloc(size);
			this.copyBuffers.push({
				addr, buf, size
			});
		}
	}
	addr = utils.pad64(addr);
	size = utils.pad64(size);
	if (third !== undefined) { da.push([addr, size, third]); } else { da.push([addr, size]); }
	return this;
};

IPCMessage.prototype.aDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.aDescriptors, addr, size, perm);
};

IPCMessage.prototype.bDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.bDescriptors, addr, size, perm);
};

/*
	type 0xA buffers have u16 length shenanigans
 */
IPCMessage.prototype.cDescriptor = function (addr, size, hasU16Length) {
	return this.addDescriptor(this.cDescriptors, addr, size, hasU16Length);
};

IPCMessage.prototype.xDescriptor = function (addr, size, counter) {
	return this.addDescriptor(this.xDescriptors, addr, size, counter);
};

IPCMessage.prototype.copyHandle = function (handle) {
	this.copiedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.moveHandle = function (handle) {
	this.movedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.inputObjectId = function (id) {
	this.inputObjectId.push(utils.trunc32(id));
	return this;
};

IPCMessage.prototype.toObject = function (object) {
	this.objectDomainCommand = 1;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.closeObject = function (object) {
	this.objectDomainCommand = 2;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.pack = function () {
	/*
    Structure of an IPC packet:
    2*u32 header
      type
      number of descriptors
      length of raw data section / 4
      "flags for buf c descriptors"
      enable handle descriptor
    x descriptors
    a descriptors
    b descriptors
    w descriptors
    raw data section
      padding
      aligned data section
      padding
      c descriptor lengths
    c descriptors
   */
	var alignedDataSection = [];
  
	var dataPayload = [];
	dataPayload.push(0x49434653);
	dataPayload.push(0);
	dataPayload.push(this.cmdId);
	dataPayload.push(0);
	for (var i = 0; i < this.dataBuffer.length; ++i) {
		dataPayload.push(this.dataBuffer[i]);
	}
  
	if (this.objectDomainCommand !== undefined) {
		alignedDataSection.push(this.objectDomainCommand | ((dataPayload.length * 4) << 16));
		alignedDataSection.push(this.objectId);
		alignedDataSection.push(0);
		alignedDataSection.push(0);
	}

	alignedDataSection = alignedDataSection.concat(dataPayload);

	var cDescriptorSection = [];
	for (var i = 0; i < this.cDescriptors.length; ++i) {
		var v = this.cDescriptors[i];
		var addr = utils.trunclt64(v[0], 48);
		var size = utils.trunclt32(v[1], 16);
		cDescriptorSection.push(addr[0]);
		cDescriptorSection.push((addr[1] & 0xFFFF) | (size << 16));
	}

	var cDescriptorsWithU16Length = this.cDescriptors.filter((c) => c[2]);
	var u16Lengths = cDescriptorsWithU16Length.map((c) => c[1][0]);
	if(u16Lengths.length % 2 > 0) {
		u16Lengths.push(0);
	}
	var cDescriptorLengthsSection = Array.from(new Uint32Array(new Uint16Array(u16Lengths).buffer));
  
	var descriptorSection = [];

	// handle descriptor
	if (this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) {
		descriptorSection.push((this.pid ? 1 : 0) | (this.copiedHandles.length << 1) | (this.movedHandles.length << 5)); // Handle descriptor
		if (this.pid) {
			descriptorSection.push(0);
			descriptorSection.push(0);
		}
		for (var i = 0; i < this.copiedHandles.length; ++i) { descriptorSection.push(this.copiedHandles[i]); }
		for (var i = 0; i < this.movedHandles.length; ++i) { descriptorSection.push(this.movedHandles[i]); }
	}

	// x descriptors
	for (var i = 0; i < this.xDescriptors.length; ++i) {
		var v = this.xDescriptors[i];
		var addr = v[0];
		var size = utils.trunc32(v[1]);
		var counter = v[2];
		descriptorSection.push(
			(counter & 0x3F) |
			(((addr[1] & 0x70) >>> 4) << 6) |
			(counter & 0xE00) |
			((addr[1] & 0xF) << 12) |
			size << 16
		);
		descriptorSection.push(addr[0]);
	}

	// a & b descriptors
	for (var i = 0; i < this.aDescriptors.length + this.bDescriptors.length; ++i) {
		var v = i < this.aDescriptors.length ? this.aDescriptors[i] : this.bDescriptors[i - this.aDescriptors.length];
		var addr = v[0];
		var size = utils.pad64(v[1]);
		var perm = v[2];
		descriptorSection.push(size[0]);
		descriptorSection.push(addr[0]);
		descriptorSection.push(
			perm |
			(((addr[1] & 0x70) >>> 4) << 2) |
			((size[1] & 0xF) << 24) |
			((addr[1] & 0xF) << 28)
		);
	}

	var rawDataSection = [];
	var rawDataOffset = 2 + descriptorSection.length; // 2 header bytes + descriptors
	while (((rawDataSection.length + rawDataOffset) & 3) !== 0) { rawDataSection.push(0); } // padding
	var paddingLength = rawDataSection.length;
	rawDataSection = rawDataSection.concat(alignedDataSection);
	for (var i = 0; i < 4-paddingLength; ++i) { rawDataSection.push(0); } // 0x10 bytes total padding
	rawDataSection = rawDataSection.concat(cDescriptorLengthsSection);

	var headerSection = [];
	headerSection.push(
		this.type | // Request
		(this.xDescriptors.length << 16) |
		(this.aDescriptors.length << 20) |
		(this.bDescriptors.length << 24) |
		(0 << 28) // W descriptors count
	);
	headerSection.push(
		(rawDataSection.length) |
		((this.cDescriptors.length !== 0 ? this.cDescriptors.length + 2 : 0) << 10) |
		(((this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) ? 1 : 0) << 31)
	);

	var buf = headerSection.concat(descriptorSection);
	buf = buf.concat(rawDataSection);
	buf = buf.concat(cDescriptorSection);
  
	for (var i = 0; i < buf.length; ++i) { buf[i] = buf[i] >>> 0; }

	return buf;
};

IPCMessage.prototype.sendTo = function (handleName) {
	var handle = handleName;
	if (!(handleName instanceof Array) && typeof(handleName) !== "number") {
		handle = this.sender.getAutoHandle(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}
	this.sc.ipcBuf.set(this.sc.emptyIpcBuf);
	this.sc.ipcBuf.set(this.packed);

	var self = this;

	if (this.sc !== this.sender) {
		this.sender.memcpyFromBrowser(this.sender.ipcBufAddr, this.sc.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyFromBrowser(cr.addr, cr.buf, cr.size);
		});
	}

	var ret = this.sender.svcSendSyncRequestWithUserBuffer(this.sender.ipcBufAddr, 0x2000, handle);

	if(!ret.isOk) {
		if (handle !== handleName) { // Remote port dead -- our handle is bad now
			this.sender.killAutoHandle(handleName);
		}
	}

	if (this.sc !== this.sender) {
		this.sender.memcpyToBrowser(this.sc.ipcBufAddr, this.sender.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyToBrowser(cr.buf, cr.addr, cr.size);
		});
	}

	if(ret.isOk) {
		return new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null);
	} else {
		return new IPCFailure(this.sc, this.sender, ret.getError());
	}
};

IPCMessage.prototype.asyncSendTo = function (handleName, timeout) {
	if (this.sc !== this.sender) {
		throw new Error('asyncSendTo is only supported on sploitcore');
	}

	var handle = handleName;
	if (!(handle instanceof Array) && typeof(handle) !== "number") {
		// using auto handles with this asynchronous stuff would be a recipe for disaster
		handle = this.sc.getService(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}

	var ipcBuf = new Uint32Array(0x2000 >> 2);
	ipcBuf.set(this.packed);

	var self = this;
  
	return this.sc.asyncCaller.call(this.sc.gadget([0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]), [this.sc.getArrayBufferAddr(ipcBuf), 0x2000, handle], timeout).then((ret) => {
		if (ret[0] === 0xf601 && handle !== handleName) {
			self.sc.svcCloseHandle(handle);
		}
		if (ret[0] !== 0) {
			return new IPCFailure(self.sc, self.sender, new ResultCode(ret));
		} else {
			return new IPCMessage(self.sc, self.sender).unpack(ipcBuf, this.objectDomainCommand != null);
		}
	});
};

IPCMessage.prototype.unpack = function (buf, toDomain) {
	this.buffer = buf;
	if(toDomain === undefined) { toDomain = false; }
  
	this.dataBuffer = this.data = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];

	var xCount = (buf[0] >>> 16) & 0xF;
	var aCount = (buf[0] >>> 20) & 0xF;
	var bCount = (buf[0] >>> 24) & 0xF;
	var wCount = (buf[0] >>> 28);

	if (wCount > 0) {
		throw new Error("can't unpack W descriptors yet");
	}

	var rawDataSectionLength = (buf[1] & 0x3FF) * 4;
	var alignedDataSectionLength = rawDataSectionLength - 0x10;
	var cDescriptors = ((buf[1] >>> 10) & 0x3) - 1;
	var hasHandleDescriptor = (buf[1] >>> 31) === 1;

	var pos = 2;

	if (hasHandleDescriptor) {
		var hd = buf[pos++];
		var hasPid = !!(hd & 1);
		var copyCount = (hd >>> 1) & 0xF;
		var moveCount = hd >>> 5;
		if (hasPid) { this.pid = [buf[pos++], buf[pos++]]; }
		for (var i = 0; i < copyCount; ++i) { this.copiedHandles.push(buf[pos++]); }
		for (var i = 0; i < moveCount; ++i) { this.movedHandles.push(buf[pos++]); }
	}

	for (var i = 0; i < xCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [b, (((a >>> 12) & 0xF) | ((a >>> 2) & 0x70)) >>> 0];
		var size = [a >>> 16, 0];
		var counter = (a & 0xE3F) >>> 0;
		this.xDescriptors.push([addr, size, counter]);
	}

	for (var i = 0; i < aCount + bCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var c = buf[pos++];
		var addr = [b, ((((c >>> 2) << 4) & 0x70) | ((c >>> 28) & 0xF)) >>> 0];
		var size = [a, ((c >>> 24) & 0xF) >>> 0];
		var perm = c & 3;
		if (i < aCount) { this.aDescriptors.push([addr, size, perm]); } else { this.bDescriptors.push([addr, size, perm]); }
	}

	var rawDataSectionOffset = pos;
	// padding
	if ((pos & 3) !== 0) { pos += 4 - (pos & 3); }

	var dataPayloadLength = alignedDataSectionLength;
	if (toDomain) {

		this.objectDomainCommand = buf[pos] & 0xFF;

		if(this.objectDomainCommand === 2) {
			dataPayloadLength = 0;
		}

		var dataLength = (buf[pos++] >> 16) + 0x10;
		var inputObjectIdCount = (dataPayloadLength - dataLength - 0x10) / 4;
		dataPayloadLength = dataLength;

		this.objectId = buf[pos++];
		pos+= 2;
	}

	this.packed = Array.from(buf);
  
	if(dataPayloadLength > 0) {
		var dataPayloadBegin = pos;
    
		if ((buf[pos] & 0x00FFFFFF) !== 0x434653) {
			utils.hexdump("bad msg", buf, 0x50);
			throw new Error("SFCI/SFCO wasn't in expected position");
		}
    
		pos += 2;
		this.cmdId = this.resultCode = buf[pos];
		this.success = this.cmdId === 0;
		pos+= 2;
    
		while (pos < dataPayloadBegin + (dataPayloadLength >> 2)) {
			this.data.push(buf[pos++]);
		}
	}

	if (toDomain) {
		while (inputObjectIdCount > 0) {
			// TODO: the u32 are technically unaligned.
			this.inputObjectIds.push(buf[pos++]);
			inputObjectIdCount -= 1;
		}
	}

	pos = rawDataSectionOffset + (rawDataSectionLength >> 2);
  
	for(var i = 0; i < cDescriptors; i++) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [a, (b & 0xFFFF) >>> 0];
		var size = [b >>> 16, 0];
		this.cDescriptors.push([addr, size]);
	}
  
	return this;
};

IPCMessage.prototype.show = function () {
	utils.log('IPC message:');
	if (this.resultCode !== 0) { utils.log('- Command ID / Result code: ' + new ResultCode(this.resultCode).toString()); }
	if (this.pid !== null) { utils.log('- PID: ' + utils.paddr(this.pid)); }
	if (this.dataBuffer.length > 0) {
		utils.log('- Data');
		utils.hexdump("    data", new Uint32Array(this.dataBuffer));
	}
	if (this.copiedHandles.length > 0) {
		utils.log('- Copied handles');
		for (var i = 0; i < this.copiedHandles.length; ++i) { utils.log('    - 0x' + this.copiedHandles[i].toString(16)); }
	}
	if (this.movedHandles.length > 0) {
		utils.log('- Moved handles');
		for (var i = 0; i < this.movedHandles.length; ++i) { utils.log('    - 0x' + this.movedHandles[i].toString(16)); }
	}
	if (this.inputObjectIds.length > 0) {
		utils.log('- Input Objects');
		for (var i = 0; i < this.inputObjectIds.length; ++i) { utils.log('    - 0x' + this.inputObjectIds[i].toString(16)); }
	}
	if (this.aDescriptors.length > 0) { utils.log('- ' + this.aDescriptors.length + ' A descriptor' + (this.aDescriptors.length > 1 ? 's' : '')); }
	if (this.bDescriptors.length > 0) { utils.log('- ' + this.bDescriptors.length + ' B descriptor' + (this.bDescriptors.length > 1 ? 's' : '')); }
	if (this.cDescriptors.length > 0) { utils.log('- ' + this.cDescriptors.length + ' C descriptor' + (this.cDescriptors.length > 1 ? 's' : '')); }
	if (this.xDescriptors.length > 0) { utils.log('- ' + this.xDescriptors.length + ' X descriptor' + (this.xDescriptors.length > 1 ? 's' : '')); }

	return this;
};

IPCMessage.prototype.showPacked = function () {
	utils.hexdump("ipcm", this.pack());
	return this;
};

IPCMessage.prototype.toBuilderString = function () {
	function fmtU32Array(arr) {
		return arr.map((u32) => "0x" + u32.toString(16)).join(", ");
	}
  
	var str = "sc.ipcMsg(" + this.cmdId + ")";
	if(this.type !== 4) { str+= ".setType(" + this.type + ")"; }
	if(this.dataBuffer.length > 0) { str+= ".data(" + fmtU32Array(this.dataBuffer) + ")"; }
	this.aDescriptors.forEach((ad) => {
		str+= ".aDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.bDescriptors.forEach((ad) => {
		str+= ".bDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.cDescriptors.forEach((ad) => {
		str+= ".cDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.xDescriptors.forEach((ad) => {
		str+= ".xDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.copiedHandles.forEach((ch) => {
		str+= ".copyHandle(0x" + ch.toString(16) + ")";
	});
	this.movedHandles.forEach((ch) => {
		str+= ".moveHandle(0x" + ch.toString(16) + ")";
	});
	this.inputObjectIds.forEach((ch) => {
		str+= ".inputObjectId(0x" + ch.toString(16) + ")";
	});
	if(this.objectDomainCommand) {
		switch(this.objectDomainCommand) {
		case 1:
			str+= ".toObject(" + this.objectId + ")";
			break;
		case 2:
			str+= ".closeObject(" + this.objectId + ")";
			break;
		default:
			throw new Error("unknown domain command");
		}
	}
	return str;
};

IPCMessage.prototype.assertOk = function () {
	if(!this.success) {
		this.show();
		throw new ResultCode(this.resultCode);
	} else {
		return this;
	}
};

IPCMessage.prototype.asResult = function () {
	if(this.success) {
		return new Result.Ok(this);
	} else {
		return new Result.Err(this);
	}
};

// calls cb if our result code == 0, err otherwise
// cb signature is (msg, moved, copied) => { ... }
// returns value returned from cb
IPCMessage.prototype.withHandles = function(cb, err) {
	try {
		if(this.success) {
			return cb(this, this.movedHandles, this.copiedHandles);
		} else {
			if(err) {
				return err(this, this.movedHandles, this.copiedHandles);
			} else {
				return this;
			}
		}
	} finally {
		var sender = this.sender;
		this.movedHandles.forEach((mh) => {
			sender.svcCloseHandle(mh);
		});
		this.copiedHandles.forEach((ch) => {
			sender.svcCloseHandle(ch);
		});
	}
};

IPCMessage.prototype.toString = function() {
	return "IPCMessage(" + this.cmdId + " = " + new ResultCode(this.resultCode).toString() + ")";
};

function IPCFailure(sc, sender, resultCode) {
	this.resultCode = resultCode;
	this.sc = sc;
	this.sender = sender;
}

IPCFailure.prototype.assertOk = function () {
	this.show();
	throw this.resultCode;
};

IPCFailure.prototype.asResult = function () {
	return new Result.Err(this);
};

IPCFailure.prototype.withHandles = function(ok, err) {
	if(err) {
		return err(this, [], []);
	} else {
		return this;
	}
};

IPCFailure.prototype.show = function () {
	utils.log("IPC Failure: " + this.resultCode.message + ", offending request shown below");
	new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null).show();
	return this;
};

IPCFailure.prototype.toString = function () {
	return "IPCFailure(" + this.resultCode.toString() + ")";
};

IPCFailure.prototype.success = false;
IPCFailure.prototype.isFailure = true;

sploitMixin.ipcMsg = function (cmdId) {
	return new IPCMessage(this.sc, this, cmdId);
};

/*
  If no `cb` is passed, return a Result.
    Ok(u32 handle) if everything is okay
    Err(ResultCode) if `sm:` returned an unsuccessful result code
    Throw if `name` is not a string, no such service exists, or we fail to connect to `sm:`
  If `cb` is passed:
    Calls `cb` with the `u32 handle` if successful. If we fail to get a handle, throw.
    Returns value returned from `cb` and automatically closes handle after `cb` returns.
 */
sploitMixin.getService = function (name, cb) {
	if (typeof(name) !== "string") {
		throw new Error("cannot get service with non-string name");
	}
	
	/* We can only query services if we have smhax. */
	if (utils.hasSmhax()) {
		if (!this.sc.hasService(name)) {
			throw new Error('no such service');
		}
	}

	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
		
		/* Without smhax we have to initialize sm. */
		if (!utils.hasSmhax()) {
			this.ipcMsg(0).sendPid().datau64(0).sendTo(this.smHandle).assertOk();
		}
	}
	var lol = utils.str2u64(name);
	var r = this.ipcMsg(1).datau64(lol).sendTo(this.smHandle).asResult().map((response) => response.movedHandles[0]);
	if(cb === undefined) {
		return r;
	} else {
		var h = r.assertOk();
		try {
			return cb(h);
		} finally {
			this.svcCloseHandle(h);
		}
	}
};

sploitMixin.getServices = function(services, callback) {
	var serviceHandles = [];

	for (var si = 0; si < services.length; si++) {
		var service = this.getService(services[si]).assertOk();
		serviceHandles.push( service );
	}

	try {
		return callback.apply(undefined, serviceHandles);
	} finally {
		for (var shi = 0; si < serviceHandles.length; shi++) {
			this.svcCloseHandle(serviceHandles[shi]);
		}
	}
};

sploitMixin.registerService = function (name, maxSessions) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	if (maxSessions === undefined) {
		maxSessions = 1000;
	}
	var lol = utils.str2u64(name);
	utils.dlog('Registering service ' + name);
	return this.ipcMsg(2).datau64(lol, [maxSessions, 0x20]).sendTo(this.smHandle).asResult().map((r) => r.movedHandles[0]);
};

sploitMixin.unregisterService = function (name) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	var lol = utils.str2u64(name);
	return this.ipcMsg(3).datau64(lol).sendTo(this.smHandle).asResult();
};

sploitcore.prototype.hasService = function (name) {
	if (this.ipcServices[name] === undefined) {
		var r = this.registerService(name, 1000);
		if(r.isOk) {
			this.ipcServices[name] = false;
			this.unregisterService(name).assertOk();
		} else {
			this.ipcServices[name] = true;
		}
	}
	return this.ipcServices[name];
};

sploitMixin.getAutoHandle = function (name) {
	if (this.ipcHandles[name] === undefined) {
		if (name instanceof Function) {
			this.ipcHandles[name] = name();
		} else if (typeof(name) === "string") {
			this.ipcHandles[name] = this.getService(name).assertOk();
		} else {
			throw new Error("invalid auto handle type " + name);
		}
	}
	return this.ipcHandles[name];
};

sploitMixin.killAutoHandle = function (name) {
	if (name === undefined) {
		for (var name in this.ipcHandles) {
			this.killAutoHandle(name);
		}
		return;
	}

	if (this.ipcHandles[name] === undefined) { return; }

	this.svcCloseHandle(this.ipcHandles[name]).assertOk();
	delete this.ipcHandles[name];
};

module.exports = IPCMessage;
