/* eslint no-global-assign: "off" */
/* global XMLHttpRequest */
var DEBUG = false;

var utils = exports;

exports.paddr = function paddr (lo, hi) {
	if (arguments.length === 1) {
		hi = lo[1];
		lo = lo[0];
	}
	var slo = ('00000000' + lo.toString(16)).slice(-8);
	var shi = ('00000000' + hi.toString(16)).slice(-8);
	return '0x' + shi + slo;
};

exports.parseAddr = function parseAddr (addr) {
	addr = "0000000000000000" + addr.replace('0x', '');
	addr = addr.slice(addr.length - 16);
	var arr = [addr.slice(0, 8), addr.slice(8, 16)];
	var hi = parseInt(arr[0], 16);
	var lo = parseInt(arr[1], 16);
	return [ lo, hi ];
};

exports.nullptr = function nullptr (addr) {
	return addr[0] === 0 && addr[1] === 0;
};

exports.eq = function eq (a, b) {
	return a[0] === b[0] && a[1] === b[1];
};

exports.add2 = function add2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	var alo = addr[0];
	var ahi = addr[1];
	var blo = off[0];
	var bhi = off[1];

	var nlo = ((alo + blo) & 0xFFFFFFFF) >>> 0;
	var nhi = ((ahi + bhi) & 0xFFFFFFFF) >>> 0;

	if ((nlo < alo && blo > 0) || (nlo === alo && blo !== 0)) {
		nhi = ((nhi + 1) & 0xFFFFFFFF) >>> 0;
	} else if (nlo > alo && blo < 0) {
		nhi = ((nhi - 1) & 0xFFFFFFFF) >>> 0;
	}

	return [nlo, nhi];
};

exports.sub2 = function sub2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	off = exports.add2([off[0] ^ 0xFFFFFFFF, off[1] ^ 0xFFFFFFFF], 1);
	return exports.add2(addr, off);
};

exports.send = function send (ep, data) {
	var msg = {
		msg: data
	};
	var jsonstr = JSON.stringify(msg);
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('POST', '/' + ep, false);
		xhr.setRequestHeader('Content-Type', 'application/json');
		xhr.send(jsonstr);
	} catch (e) {

	}
};

exports.pushCache = function pushCache (cache) {
	exports.send('cache', cache);
};

exports.dlog = function dlog (msg) {
	if (DEBUG) {
		log(msg);
	}
};

exports.toHex = function (d) {
	return d.toString(16);
};

/*
  example:
  utils.packBitfield([
    {targetBegin: 16, size: 4},
    {targetBegin: 20, targetEnd: 24},
    {targetBegin: 24, size: 4, sourceBegin: 2}], [5, 6, 7])
 */
exports.packBitfield = function (spec, values) {
	var bitfield = 0;
	if(spec.length !== values.length) {
		throw "bitfield spec doesn't match number of provided values";
	}
	for(var i = 0; i < spec.length; i++) {
		var s = spec[i];
		var v = values[i];
    
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		bitfield = bitfield | (((v >> sb) & ((1<<size)-1)) << tb);
	}

	return bitfield;
};

exports.unpackBitfield = function (spec, bitfield) {
	return spec.map((s) => {
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		return ((bitfield >> tb) & ((1<<size)-1)) << sb;
	});
};

exports.assertu32 = function (num) {
	if(!Number.isInteger(num)) {
		throw new Error("expected integer");
	}
	if(num > 0xFFFFFFFF) {
		throw new Error("too large for u32");
	}
	if(num < 0) {
		throw new Error("expected positive integer");
	}
	return num;
};

exports.assertu64 = function (arr) {
	if(!Array.isArray(arr)) {
		throw new Error("expected array");
	}
	if(arr.length !== 2) {
		throw new Error("expected [lo, hi] pair");
	}
	return [this.assertu32(arr[0]), this.assertu32(arr[1])];
};

exports.trunc32 = function (num) {
	if(Array.isArray(num)) {
		if(num[1] !== 0) {
			throw new Error("high 32 bits must be clear");
		}
		return this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		return this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
};

// truncate to less than 32 bits, will always return number
// throw when truncating non-zero bits
exports.trunclt32 = function (num, bits) {
	if(bits > 32) {
		throw new Error("can't truncate > 32 bits with trunclt32");
	}
	if(Array.isArray(num) && this.assertu64(num)) {
		if(num[1] !== 0) {
			throw new Error("high " + (64-bits) + " bits must be clear");
		}
		num = this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		num = this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 32 ? 0 : (num >> bits) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

// truncate to less than 64 bits, will always return [lo, hi]
// throw when truncating non-zero bits
exports.trunclt64 = function (num, bits) {
	num = this.pad64(num);
	if(this.bits <= 32) {
		return [this.trunclt32(num), 0];
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 64 ? 0 : (num[1] >> (bits-32)) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

exports.pad64 = function (num) {
	if(Array.isArray(num)) {
		return this.assertu64(num);
	} else if(typeof(num) === "number") {
		return [this.assertu32(num), 0];
	} else {
		throw new Error("expected [lo,hi] or number");
	}
};

console = {
	log: function (msg) {
		exports.send('log', msg);
	}
};

var log = console.log;

exports.log = log;

exports.dump = function (name, buf, count) {
	for (var j = 0; j < count; ++j) { utils.log(name + '[' + j + '] == 0x' + buf[j].toString(16)); }
};

exports.hexdump = function (name, inp, count) {
	var buf;
	var u8b;

	if (inp instanceof ArrayBuffer || inp instanceof Uint32Array) {
		buf = inp;
		u8b = new Uint8Array((inp instanceof ArrayBuffer) ? buf : buf.buffer);
		if (count === undefined) {
			count = u8b.length;
		}
	} else {
		buf = new ArrayBuffer(inp.length * 4);
		var u32b = new Uint32Array(buf);
		u8b = new Uint8Array(buf);
		if (count === undefined) {
			count = u8b.length;
		}
		for (var i = 0; i < inp.length && i < count; i++) {
			u32b[i] = inp[i];
		}
	}
	var rows = Math.ceil(count / 16.0);
	var addrColumnWidth = (name + '+0x' + (rows * 16).toString(16)).length;
	var dumpWidth = (3 * 16) + 1; // 2 characters + 1 space for each of the 16 bytes, and the space between u32s

	function rjust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return fill + string;
	}

	function ljust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return string + fill;
	}

	for (i = 0; i < rows; i++) {
		var offset = i * 16;
		var hexlinedump = '';
		var asciilinedump = '';
		for (var j = 0; j < 16 && offset + j < count; j++) {
			if (j !== 0) {
				hexlinedump += ' ';
			}
			hexlinedump += rjust(u8b[offset + j].toString(16), 2, '0');
			if (j === 7) hexlinedump += ' ';

			asciilinedump += String.fromCharCode(u8b[offset + j]).replace(/[^\x20-\x7E]+/g, '.');
		}
		var linedump = ljust(hexlinedump, dumpWidth, ' ') + '| ' + ljust(asciilinedump, 16, ' ') + ' |';
		utils.log(ljust(name + '+0x' + offset.toString(16), addrColumnWidth, ' ') + ' | ' + linedump);
	}
};

exports.str2ab = function (str, length) {
	if(length === undefined) {
		length = str.length + 1;
	} else {
		if(length < str.length + 1) {
			throw new Error("buffer is too small to pack string");
		}
	}
	var ab = new ArrayBuffer(length);
	var u8 = new Uint8Array(ab);
	for (var i = 0; i < str.length; i++) {
		u8[i] = str.charCodeAt(i);
	}
	u8[str.length + 1] = 0;
	return ab;
};

exports.u8a2str = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.u8a2nullstr = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		if(u8[i] === 0) {
			break;
		}
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.str2u64 = function (inp) {
	if (inp.length > 8) {
		throw new Error("string too long");
	}
	if (inp.length === 0) {
		return [0, 0];
	}
	var len = 8;
	var buf = new ArrayBuffer(len);
	var u8b = new Uint8Array(buf);
	for (var j = 0; j < inp.length; ++j) { u8b[j] = inp.charCodeAt(j); }
	for (j = inp.length; j < len; ++j) { u8b[j] = 0; }

	var u32b = new Uint32Array(buf);
	return [u32b[0], u32b[1]];
};

exports.version = 0;

exports.hasSmhax = function () {
    return exports.version < 301;
}
